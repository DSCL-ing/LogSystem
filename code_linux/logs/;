#ifndef MANAGER_HPP
#define MANAGER_HPP

#include<unordered_map>

#include"builder.hpp"
#include"logger.hpp"

#if !defined(BUILDER_HPP) || defined(IN_A_HPP)
#include "a.hpp"
#endif


/*
  日志器管理器
  单例--全局唯一
  用map管理日志
  map互斥
  _root_logger //原始日志器
    
  添加日志器 map.insert
  日志器是否已管理exists -- , map.find
  获取日志器 map[loggername];
  获取默认日志器 --- 方便用户
 
  //日志器几乎不删除
 */

namespace log{
  class LogManager{
    public:
      static LogManager& getInstance(){
        static LogManager _instance;//只会初始化一次,线程安全
        return _instance; 
      }
      void addLogger(std::shared_ptr<Logger>&logger){ //自动获取日志器名
        if(hasLogger(logger->name()))
        std::lock_guard<std::mutex> lg(_mutex);
        _loggers.insert(std::make_pair(logger->name(),logger));
      }

      bool hasLogger(const std::string& name){
        auto it = _loggers.find(name);
        return it==_loggers.end()? false:true; 
      }

      std::shared_ptr<Logger> getLogger(const std::string&name){
        return hasLogger(name)? _loggers[name] :  nullptr;
      }
      
      std::shared_ptr<Logger> rootLogger(){
        return _root_logger;
      }

    private:
      LogManager(){
        //emmmmm....  
        std::unique_ptr<LoggerBuilder> builder(new LocalLoggerBuilder());
        builder->buildLoggerName("root");
        _root_logger = builder->build();
        addLogger(_root_logger);
      };

    private:
      std::unordered_map<std::string,std::shared_ptr<Logger>> _loggers;
      std::mutex _mutex;
      std::shared_ptr<Logger> _root_logger;
  };

}

#endif
