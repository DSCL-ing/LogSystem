#ifndef BUFFER_HPP
#define BUFFER_HPP



//同步写日志过程(直接落地)可能写的比较慢,写入量多等,为了避免因写日志过程阻塞带来的影响,实现异步落地日志器
//异步:(间接落地)不让业务线程进行日志的实际落地操作,而是将日志消息放到缓冲区(一块指定的内存)中,让一个专门的异步线程去将该缓冲区中的数据进行处理
 
//异步优点:避免了同步日志可能因IO问题阻塞的情况
//异步缺点:理想情况下,没有同步日志快 


//日志一般只会用一个线程 -- 主要资源用于业务
//但也要保证线程安全 -- 

  //异步缓冲区实现路程:
  /*
  1. 队列 先进先出特性 --> STL队列:链式队列,输入输出过程频繁申请与释放内存,性能浪费严重. 生产消费竞争锁,效率低
  2. 环形队列 定长,循环使用 --> 生产消费模型:竞态行为不那么严重: 主要瓶颈:高并发场景中信号量为主要性能开销,信号量涉及内核态,频繁切换开销
  3. 双缓冲 交换---> 避免生产与消费频繁的锁冲突(串行化) 优点:只在生产满时或消费完时发生生产消费一次互斥; 输出: 一次性IO输出,减少IO次数,提高效率
    //高效 -- linux 网络IO中接收,发送双缓冲区...
  */

 /*
  缓冲区设计: 一个缓冲区负责输入,另一个缓冲区负责输出; 当其中一个满足条件时,进行角色交换;另一个为空时,不交换
  存储数据类型: 只存储格式化好的字符串 -- 避免Msg对象频繁创建带来的性能开销
  数据结构: std::vector -- 
  读指针rseek: 指向当前读取的位置,读到写指针位置时,表明读完,交换
  写指针wseek: 指向当前写入的位置,写到读指针位置时,表示写满,交换

  提供的缓冲区管理操作:
  - 读写操作
    1.向缓冲区中写入数据 push()
    2.从缓冲区中读入数据 (虚:读数据会再次发生拷贝,原位置不需要保留 --> 不读,直接移动 --> 几乎与同步日志效率一样)
    -.读写指针偏移  1.读指针偏移moveReader 2.写指针偏移moveWrite 3.获取可读数据起始地址begin 4.获取可读数据长度readAbleSize() 5.可写数据长度
  - 初始化 reset()
  - 交换(地址交换) 1.empty()
 
logic:
    buffer( rseek, wseek, _vector<字节流>)
        写入push --- len>writeAbleSize()? 扩容,写入:写入 --- moveWseek()
            扩容ensure
        读出 Read: ReadAbleSize + moveRseek
            



 */

namespace log{
    class Buffer{
    public:
        Buffer()
        {} 
        void push(){
            
        }
        
        //返回可读数据的起始地址
        const char* begin(){
            
        }

    };

}//namespace_log__END



#endif